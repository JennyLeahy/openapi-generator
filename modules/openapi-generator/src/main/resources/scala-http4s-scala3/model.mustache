{{>licenseInfo}}
package {{modelPackage}}

import io.circe.*
import io.circe.syntax.*
import io.circe.{ Decoder, Encoder }

{{#imports}}
import {{import}}
{{/imports}}

{{#models}}
{{#model}}
/**
* {{{description}}}
{{#vars}}
* @param {{name}} {{{description}}}
{{/vars}}
*/
{{#isEnum}}
enum {{classname}}(val value: String) {
  {{#allowableValues}}
  {{#values}}
  case {{#fnEnumEntry}}{{#lambda.camelcase}}{{.}}{{/lambda.camelcase}}{{/fnEnumEntry}} extends {{classname}}("{{.}}")
  {{/values}}
  {{/allowableValues}}
}

object {{classname}} {
  given decoder{{classname}}: Decoder[{{classname}}] =
    Decoder.decodeString.map(str => {{classname}}.valueOf(str))
  given encoder{{classname}}: Encoder[{{classname}}] =
    Encoder.encodeString.contramap[{{classname}}](_.value)
}
{{/isEnum}}
{{^isEnum}}
case class {{classname}}(
{{#vars}}
  {{name}}: {{^required}}Option[{{{dataType}}}]{{/required}}{{#required}}{{{dataType}}}{{/required}}{{^-last}},{{/-last}}
{{/vars}}
)
  
object {{classname}} {
  given encoder{{classname}}: Encoder[{{classname}}] = Encoder.instance { t =>
    Json.fromFields{
      Seq(
        {{#vars}}
        {{#required}}Some("{{#lambda.snakecase}}{{name}}{{/lambda.snakecase}}" -> t.{{name}}.asJson){{/required}}{{^required}}t.{{name}}.map(v => "{{#lambda.snakecase}}{{name}}{{/lambda.snakecase}}" -> v.asJson){{/required}}{{^-last}},{{/-last}}
        {{/vars}}
      ).flatten
    }
  }
  given decoder{{classname}}: Decoder[{{classname}}] = Decoder.instance { c =>
    for {
      {{#vars}}
      {{name}} <- c.downField("{{#lambda.snakecase}}{{name}}{{/lambda.snakecase}}").as[{{^required}}Option[{{{dataType}}}]{{/required}}{{#required}}{{{dataType}}}{{/required}}]
      {{/vars}}
    } yield {{classname}}(
      {{#vars}}
      {{name}} = {{name}}{{^-last}},{{/-last}}
      {{/vars}}
    )
  }
}
{{/isEnum}}
{{/model}}
{{/models}}

