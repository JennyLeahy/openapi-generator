{{>licenseInfo}}
package {{apiPackage}}

import cats.effect.Concurrent
import io.circe.Encoder
import org.http4s.Uri
import org.http4s.client.Client as Http4sClient
{{#imports}}
import {{import}}
{{/imports}}
import {{modelPackage}}.*

{{#operations}}
trait {{classname}}Endpoints[F[*]] {

{{#operation}}
  def {{operationId}}({{>methodParameters}}): F[{{>operationReturnType}}]
{{/operation}}

}
{{/operations}}

{{#operations}}
class {{classname}}EndpointsImpl[F[*]: Concurrent](
  override val baseUrl: Uri,
  auth: Option[Authorization] = None,
  defaultHeaders: Seq[(String, String)] = Nil,
  httpClient: Http4sClient[F]
) extends BaseClient[F](baseUrl, auth, defaultHeaders, httpClient) with {{classname}}Endpoints[F] {
  
  import JsonSupports.*
  import io.circe.syntax.EncoderOps
  import cats.implicits.*

{{#operation}}
  override def {{operationId}}({{>methodParameters}}): F[{{>operationReturnType}}] = {
    val requestHeaders =
      {{>headerParamCreation}}

    val urlPath = s"{{{path}}}"
    {{#hasQueryParams}}
    val queryParameters = (
      {{>queryParams}}
    ).toSeq.flatten{{/hasQueryParams}}

    _executeRequest[{{>bodyParamType}}, {{>operationReturnType}}](
      method = "{{httpMethod.toUpperCase}}",
      path = urlPath,{{#bodyParam}}
      body = Some({{paramName}}),{{/bodyParam}}{{#hasQueryParams}}
      queryParameters = queryParameters, {{/hasQueryParams}}
      requestHeaders = requestHeaders) {
      {{>responseState}}
    }
  }

  {{/operation}}
}
{{/operations}}


