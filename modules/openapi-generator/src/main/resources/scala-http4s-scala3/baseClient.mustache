{{>licenseInfo}}
package {{apiPackage}}

import cats.effect.Concurrent
import io.circe.Encoder
import org.http4s.{Header, Headers, Method, Request, Response, Uri, UrlForm}
import org.http4s.client.Client as Http4sClient
import org.http4s.QueryParamEncoder.*
import org.typelevel.ci.CIString
import java.util.Base64
import java.nio.charset.StandardCharsets
import {{modelPackage}}.*

abstract class BaseClient[F[*]: Concurrent](
    val baseUrl: Uri,
    defaultAuth: Option[Authorization] = None,
    defaultHeaders: Seq[(String, String)] = Nil,
    httpClient: Http4sClient[F]
) {

  val ApiVersion: String = "{{artifactVersion}}"

  private lazy val defaultApiHeaders = Seq(
    ("X-Apidoc-Version", ApiVersion)
  )

  protected def apiHeaders: Seq[(String, String)] = defaultApiHeaders

  protected def modifyRequest(request: Request[F]): Request[F] = request

  protected def _executeRequest[T, U](
      method: String,
      path: String,
      body: Option[T] = None,
      formBody : Option[UrlForm] = None,
      queryParameters: Seq[(String, Any)] = Nil,
      requestHeaders: Seq[(String, String)] = Nil,
      auth: Option[Authorization] = None
  )(handler: Response[F] => F[U])(implicit encoder: Encoder[T]): F[U] = {

    val m = Method.fromString(method) match {
      case Right(m) => m
      case Left(e)  => sys.error(e.toString)
    }

    val headers = Headers(
      (
        apiHeaders ++
        defaultHeaders ++
        requestHeaders
      ).groupBy(_._1).map { case (k, l) => Header.Raw(CIString(k), l.last._2) }.toList
    )

    val queryMap = queryParameters.groupBy(_._1).map { case (k, v) => k -> v.map(_._2.toString) }
    val uri      = (baseUrl / path).setQueryParams(queryMap)

    val request = Request[F](method = m, uri = uri, headers = headers)

    val reqAndMaybeAuth = auth.orElse(defaultAuth).fold(request) {
      case Authorization.Basic(username, passwordOpt) =>
        val userpass = s"$username:${passwordOpt.getOrElse("")}"
        val token    = Base64.getEncoder.encodeToString(userpass.getBytes(StandardCharsets.ISO_8859_1))
        request.putHeaders(Header.Raw(CIString("Authorization"), s"Basic $token"))
      case Authorization.Bearer(token) =>
        request.putHeaders(Header.Raw(CIString("Authorization"), s"Bearer $token"))
      case Authorization.ApiKey(apiKey) =>
        request.putHeaders(Header.Raw(CIString("api_key"), apiKey))
    }

    import JsonSupports.*
    val reqAndMaybeAuthAndBody =
      if (formBody.nonEmpty) formBody.fold(reqAndMaybeAuth)(reqAndMaybeAuth.withEntity)
      else body.fold(reqAndMaybeAuth)(reqAndMaybeAuth.withEntity)

    httpClient.run(modifyRequest(reqAndMaybeAuthAndBody)).use(handler)
  }

}
